# VueRouter原理分析

1. 你对VueRouter的了解
   1. VueRouter是Vue的扩展插件库(Vue.use)
   2. VueRouter用于实现单页面应用(SPA)
   3. 问题:什么是单页面应用?
      1. 页面是html文件,整个项目中只有一个html文件,它可以通过DOM的CRUD方法,对页面的内容进行操作,实现同一个html文件,显示不同的内容,这就是单页面应用
   4. 问题:如果不是用VueRouter,光靠Vue能否实现单页面应用?
      1. 可以,VueRouter并不是一个必不可少的库,他只是为了让我们更加方便实现单页面应用
   5. 问题:请问我们有没有学过多页面应用?
      1. 有,只不过现在不用了

2. VueRouter提供给我们的东西
   1. 构造函数
      1. VueRouter是一个函数
      2. 通过调用该函数,可以得到一个路由器对象
   2. 全局组件
      1. router-view
         1. 他相当于是占位符,当路由路径匹配之后,该组件会显示对应的路由组件
         2. **实现原理:其实就是通过响应式的效果,根据路由地址,显示对应的路由组件**
      2. router-link
         1. 会生成一个a标签,当用户点击该a标签,就会跳转到指定的路由路径下
         2. **声明式导航:通过标签的形式,引导用户进行跳转,这类操作成为声明式导航**
         3. **实现原理:默认生成一个a标签,使用event.preventDefault方法禁用a标签的默认行为,同时在click事件的回调函数中,调用编程式导航,实现路由跳转**
   3. 公共对象
      1. $router
         1. 该对象是路由器对象
         2. 他会提供一些操作路由的API方法
         3. 提供的方法
            1. push
               1. 该API可以实现路由跳转功能,在跳转掉新的路由地址时候,会保留上一次的历史记录,也就是说,之后还可以返回上一个路由
               2. **编程式导航:通过js的API,强行控制用户跳转,这类操作称为编程式导航**
               3. **实现原理:**
                  1. **hash模式下,push方法其实是使用了window.location.assign方法,实现的历史记录栈跳转,其实是一次伪跳转,因为他不会重新请求一个新的页面**
                     1. **语法:window.location.assign(hash地址)**
                  2. **history模式下,push方法其实是使用了window.history.pushState方法,实现历史记录栈跳转**
                     1. **语法:window.history.pushState({},'','/about')**
            2. replace
               1. 该API可以实现路由跳转功能,在跳转掉新的路由地址时候,会覆盖上一次的历史记录,也就是说,之后无法返回上一个路由**
               2. **实现原理:**
                  1. **hash模式下,push方法其实是使用了window.location.replace方法,实现的历史记录栈跳转,并且覆盖上一个历史记录**
                     1. **语法:window.location.replace(hash地址)**
                  2. **history模式下,push方法其实是使用了window.history.replaceState方法****
                     1. **语法:window.history.replaceState({},'','/about')**
      2. $route
         1. 该对象是路由对象
         2. 他会提供一些当前路由相关的数据
         3. 提供的属性
            1. fullpath->当前路由的完整路径地址
            2. query
               1. 该属性用于接收query传参的数据
               2. query传参是URL传参
                  1. 格式:"/home?key=value&key2=value2"
            3. params
               1. 该属性用于接收params传参的数据
               2. params传参是URL传参
                  1. 格式:"/home/1"
                  2. 需要做的提前配置
                     1. 在声明路由path的时候,提前声明占位符,需要书写为"/home/:id"
            4. meta
               1. 该属性用于接收meta传参的数据
               2. meta传参不是URL传参
               3. 在声明路由对象的时候,可以添加一个属性meta,通过该属性可以向某个路由传入指定数据

3. 我们需要提供给VueRouter的东西
   1. 配置对象
      1. mode属性
         1. 数据类型:string
            1. hash值
               1. 代表当前VueRouter运行为hash模式
               2. 路径中会带有"#/"
               3. **实现原理:通过给window绑定事件监听(事件名:hashchange),可以监视地址栏hash值的变化,如果发生变化,就会执行回调函数,再通过window.location.hash属性即可获取到当前得路由地址**
               4. **优点**
                  1. **兼容性好,兼容IE6+**
                  2. **上线配置简单,方便操作**
                     1. **无论在哪个路由地址下刷新当前页面,请求的都是服务器的/根路径**
               5. **缺点**
                  1. **长得丑是原罪,路径中带有'#/'**
                  2. **由于其实hash值就是用来实现锚点功能的,所以hash模式路由和锚点功能冲突,无法正常使用**
            2. history值
               1. 代表当前VueRouter运行为history模式
               2. 路径中会带有"/"
               3. **实现原理:通过给window绑定事件监听(事件名:popstate),可以监视到地址栏中history值的变化,如果发生变化就会执行回调函数**
                  1. **注意:popstate事件只能用过前进,后退按钮触发****
               4. **优点**
                  1. **颜值就是正义,长得好看,路径中没有'#/'**
                  2. **history模式可以正常使用锚点功能**
               5. **缺点**
                  1. **兼容性较差,浏览器必须支持html5**
                  2. **由于history模式的地址,与后端接口极为相似,所以浏览器在刷新页面的时候,会将前端路由地址,错误识别为后端路由地址,请求后端服务器**
                     1. **如果后端服务器没有该接口,就会返回404,那么当前项目就会出错,无法正常展示**
               6. **如何解决history路径被错误识别的问题?**
                  1. **要求服务器人员将所有自己没有的接口,统一返回index.html文件**
                  2. **流程:**
                     1. **用户在/about路径下刷新页面,浏览器会请求服务器的/about接口**
                     2. **服务器发现自己没有该接口,就根据要求,默认返回index.html文件**
                     3. **浏览器接收到返回的index.html文件之后,会开始解析该文件,而该文件中会请求index.js文件**
                     4. **服务器会根据请求的内容,自动返回index.js文件**
                     5. **当浏览器接收到index.js文件之后,该文件中的VueRouter代码就会执行,将当前地址栏中的路径,作为前端路由进行识别,从而跳转到指定的路由组件显示**
      2. routes属性
         1. 数据类型:routeObj[ ]
         2. 内部对象重要属性:
            1. path->路径
               1. 当前路由的路由地址
            2. component->组件
               1. 如果当前地址栏中的地址匹配某个path,对应需要显示的组件

4. 导航守卫(又称为路由守卫)

   1. 守卫的意思:当路由开始出现跳转操作,在跳转到指定组件的过程中,会触发多个导航守卫,只有导航守卫放行,才能到达目的地

   2. 守卫可能会做的三种情况:

      1. 遣返(不允许去往目的地)
      2. 放行(允许去往目的地)
      3. 关小黑屋(出现特殊情况,需要单独隔离)

   3. 导航守卫的分类

      1. 全局守卫

         1. 全局前置守卫

            1. 在开始跳转路由之前触发

            2. ```javascript
               router.beforeEach((to, from, next) => {
                 // ...
               //to->到哪去,是与目的地组件相关的数据
               //from->从哪来,是与出发地组件相关的数据
                //next->跟放行相关操作
                 //next()->成功放行,前往目的地
                 //next(false)->不放行,回到出发地
                 //next('/login')->带你前往一个新的地方,跟传入路径相关
               })
               //绑定的位置是在路由器对象身上
               ```

               ​

         2. 全局解析守卫

            1. 在路由组件开始解析时触发

            2. ```javascript
               router.beforeResolve(()=>{})
               ```

               ​

         3. 全局后置守卫

            1. 在路由跳转结束,到达组件之后出发

            2. ```javascript
               router.afterEach((to, from) => {
                 // ...
               })
               ```

               ​

      2. 路由独享守卫

         1. 当准备跳转当前路由的时候会触发

         2. ```javascript
            const router = new VueRouter({
              routes: [
                {
                  path: '/foo',
                  component: Foo,
                  beforeEnter: (to, from, next) => {
                    // ...
                  }
                }
              ]
            })
            ```

            ​

      3. 组件内置守卫

         1. 组件进入守卫

            1. 进入组件之前触发

               ```javascript
               const Foo = {
                 data(){
                   return{
                     msg:123
                   }
                 },
                 mounted(){},
                 beforeRouteEnter(to, from, next) {
                 },
                 beforeRouteUpdate(to, from, next) {
                 },
                 beforeRouteLeave(to, from, next) {
                 }
               }
               ```

               ​

         2. 组件更新守卫

            1. 组件被复用的时候触发

         3. 组件离开守卫

            1. 离开组件之前触发

