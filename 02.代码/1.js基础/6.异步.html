<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
      什么是异步?(懒)
        现在接收到了一个事情,但是不会立即去做这个,会将这件事情延迟一段时间之后再去做
        现在执行了一个函数,但是该函数的效果会在未来的某个时间才会生效

      回调函数的定义
        1.我创建的
        2.我没调用
        3.他执行了

      请问,回调函数都是异步执行的,对吗?
        错误的
          例如:数组的回调函数,Promise的回调函数基本都是同步执行

      在js中,异步任务一共分为2种
        1.宏任务
        2.微任务

      异步任务一定晚于主线程代码执行

      存储宏任务的队列称为宏任务队列
      存储微任务的队列称为微任务队列

      队列
        数据类型:数组
        特点:先进先出,后进后出

      栈
        数据类型:数组
        特点:先进后出,后进先出

      setTimeout一定会同步执行,只是它里面的回调函数会被异步执行

      面试题:请问是宏任务优先还是微任务优先?
      答案:
        如果你将script标签中的代码视为第一宏任务,那么就是宏任务优先
        如果你不将script标签中的代码视为第一宏任务,那么就是微任务优先

      代码的执行流程:主线程代码优先执行->清空微任务队列->执行下一个宏任务

        注意:
          1.微任务队列每次执行都是清空,而宏任务每次只会拿出其中的第一个进行执行
          2.每次执行完一个宏任务之后,都会去查看一下微任务队列中是否具有微任务

      宏任务:
        1.定时器
        2.事件相关
        3.ajax相关

      微任务:
        1.then
        2.mutationObserver
          当他监视的DOM节点发生变化时,就会开启一个微任务

      注意:以上这些方法不是宏任务/微任务,他们只是开启宏任务/微任务的手段
    
    */
      // [1, 2, 3].forEach(item => {
      //   console.log(item)
      // })
      // console.log('a forEach()之后')

      // new Promise((resolve, reject) => { // excutor  执行器函数
      //   console.log('b 执行excutor')
      // })

      // console.log('c new Promise()之后')

      // setTimeout(() => {
      //   console.log('d 执行timout回调')
      // }, 0);

      // console.log('e setTimeout()之后')

      // Promise.resolve(1).then(() => {
      //   console.log('f promise成功的回调')
      // })

      // Promise.resolve(1).then(() => {
      //   console.log('g promise成功的回调')
      // })

      // console.log('h .then之后')

      setTimeout(() => {
        console.log(1);

        Promise.resolve().then(() => {
          console.log(2);
        });

        Promise.resolve().then(() => {
          console.log(3);
        });

      }, 0);

      Promise.resolve().then(() => {
        console.log(4);
      });

      setTimeout(() => {
        console.log(5);
      }, 0);
    </script>
  </body>
</html>
