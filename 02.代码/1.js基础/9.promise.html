<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            Promise
                数据类型:函数(构造函数)
                函数一共接收几个实参
                    1个,是执行器函数
                        执行器函数会被同步调用
                        执行器函数接收几个参数
                            实参都是函数数据类型
                            resolve
                                如果当前方法被调用,那么p1对象就会变为成功状态

                            reject
                                如果当前方法被调用,那么p1对象就会变为失败状态
                                同时会在控制台中出现报错,但是该报错不会影响到后续代码的执行

                            可以在调用上述两个函数的时候,向内部传入实参,传入的数据会变成p1对象的result

                返回值:一个promise对象(简称p1对象)
                    promise对象一共具有几种状态?
                        1.pending->等待
                        2.resolved/fulfilled->成功/完成
                        3.rejected->失败

                        注意:
                            1.默认值是pending状态
                            2.promise的状态变化不可逆,只能变化一次

        .then函数
            用处:监视p1对象的状态变化,如果状态发生变化就执行对应的回调函数

            接收参数个数
                2个(数据类型都是函数)
                第一个实参是成功的回调函数
                    如果p1的状态变为成功,就会执行该函数,同时该函数的形参会接收到p1的结果值

                第二个实参是失败的回调函数
                    如果p1的状态变为失败,就会执行该函数,同时该函数的形参会接收到p1的结果值

            返回值:一个全新的promise对象(简称p2对象)
                如何控制状态变化
                    变为成功
                        1.当回调函数中的代码全部成功执行结束,返回的p2就会变为成功状态
                            完整情况:如果回调函数返回的是一个基本数据类型的数据,
                                那么p2会变为成功状态,同时该数据就会变为p2对象的结果值

                        2.回调函数中return一个成功的promise对象,返回的p2就会变为成功状态

                    变为失败
                        1.如果回调函数中的代码执行失败,返回的p2就会变为失败状态
                        2.回调函数中return一个失败的promise对象,返回的p2就会变为失败状态

            注意点:
                1.回调函数的返回值无论是什么,.then都一定返回promise对象
                2.如果p1对象状态发生变化,但是.then中没有对应的回调函数可以执行,
                    那么p2的状态就会继承p1的状态

        .catch
            用处:如果监视的p1状态变为失败,那么就执行糊掉函数
            接收参数个数:
                1个,数据类型函数
                其实就是失败的回调函数
            返回值:一个全新的promise对象

            .catch其实是.then的语法糖
                .catch(()=>{})  =>  .then(null,()=>{})
        */
        // var p1 = new Promise((resolve,reject)=>{
        //     // setTimeout(()=>{
        //     //     resolve(123);   
        //     // },1000)

        //     setTimeout(()=>{
        //         reject('哈哈');   
        //     },2000)
        //     // reject();
        //     // console.log(1)
        // })
        // console.log(p1)

        //------------------------------------------
        
        // var p1 = new Promise((resolve,reject)=>{
        //     setTimeout(()=>{
        //         resolve(123);   
        //     },1000)
        //     // reject('哈哈');   

        // })
        // // console.log(p1)
        // var p3 = Promise.resolve();

        // var p2 = p1.then(
        // (data)=>{
        //     console.log(1,data);

        //     // throw new Error('xixi');

        //     // return Promise.resolve();
        //     // return Promise.reject();
            
        //     // return p3;

        //     return 123567890;
        // },
        // (error)=>{
        //     console.log(2,error)
        // })
        // console.log(p2)

        //---------------------------------------
        
        // var p1 = new Promise((resolve,reject)=>{
        //     setTimeout(()=>{
        //         reject();   
        //     },1000)
        // })

        // p1.then(
        // ()=>{
        //     console.log(1);
        //     // throw new Error();
        // },
        // ()=>{
        //     console.log(2)
        // })
        // .then(
        // ()=>{
        //     console.log(3);
        // },
        // ()=>{
        //     console.log(4)
        // })

        // p1.then(
        // null,
        // null
        // )
        // .then(
        // ()=>{
        //     console.log(3);
        // },
        // ()=>{
        //     console.log(4)
        // })
        

        //----------------------------------
        
        // var p1 = new Promise((resolve,reject)=>{
        //     setTimeout(()=>{
        //         reject();   
        //     },1000)
        // })

        // p1.catch(()=>{
        //     console.log(1)
        // })

        
        //----------------------------------
        
        var p1 = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                reject();   
            },1000)
        })

        p1
        .then(()=>{
            console.log(1)
        })
        .catch(()=>{
            console.log(3)
        })
        .then(()=>{
            console.log(4)
        },()=>{
            console.log(5)
        })
        

    </script>
</body>
</html>